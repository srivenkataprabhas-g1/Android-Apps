# Views in Compose: Complete Study Guide
## View Interoperability in Jetpack Compose

---

## Table of Contents
1. [Introduction & Core Concepts](#introduction)
2. [AndroidView Composable](#androidview)
3. [Practical Examples](#examples)
4. [State Management](#state-management)
5. [Lifecycle Management](#lifecycle)
6. [FAQ & Best Practices](#faq)
7. [Common Use Cases](#use-cases)

---

## <a name="introduction"></a>1. INTRODUCTION & CORE CONCEPTS

### What is View Interoperability?

**Definition:** View Interoperability (View Interop) is the ability to seamlessly integrate traditional Android Views into modern Jetpack Compose applications, and vice versa.

### Why Do We Need It?

As of early 2024, not all Android UI components have Compose equivalents. Some scenarios where View Interop is essential:
- **AdView** (Google Ads/AdMob) - No native Compose component exists
- **RatingBar** - Not yet available as a Composable
- **Spinner** - Can use AndroidView for legacy implementations
- **Custom Views** - Reuse existing custom View implementations
- **Third-party Libraries** - MapView, MediaView, etc. that haven't been migrated to Compose
- **Legacy Codebases** - Gradual migration from View-based to Compose-based architecture

### Core Interoperability APIs

| API | Purpose | Use Case |
|-----|---------|----------|
| **AndroidView** | Embed traditional Views in Compose | Using legacy Views in Compose |
| **ComposeView** | Embed Compose in traditional Views | Adding Compose to View-based Activities/Fragments |
| **AndroidViewBinding** | Embed XML layouts with ViewBinding | Using pre-built XML layouts with data binding |
| **AndroidFragment** | Embed Fragments in Compose | Integrating Fragment-based components |

---

## <a name="androidview"></a>2. THE ANDROIDVIEW COMPOSABLE

### Basic Syntax

```kotlin
@Composable
fun <T : View> AndroidView(
    factory: (Context) -> T,           // Creates the View instance (called once)
    modifier: Modifier = Modifier,      // Standard Compose modifiers
    update: (T) -> Unit = NoOpUpdate   // Called whenever state changes
)
```

### Key Parameters Explained

#### **factory: (Context) -> T**
- **Called:** Only once, when the AndroidView composable first enters composition
- **Purpose:** Create and return the View instance
- **Scope:** Initialization logic only
- **Important:** Do NOT set state-dependent properties here; they won't update later

```kotlin
factory = { context ->
    // Create the view instance
    Spinner(context).apply {
        // Set up adapter and static properties
        adapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, options)
    }
}
```

#### **modifier: Modifier**
- Standard Compose modifier for sizing, padding, alignment, etc.
- Examples: `Modifier.fillMaxWidth()`, `Modifier.height(200.dp)`, `Modifier.padding(16.dp)`

```kotlin
AndroidView(
    factory = { /* ... */ },
    modifier = Modifier
        .fillMaxWidth()
        .height(100.dp)
        .padding(8.dp)
)
```

#### **update: (T) -> Unit**
- **Called:** Every time the composable recomposes
- **Purpose:** Update the View based on current Compose state
- **Critical for:** State synchronization between Compose and Views
- **Called with:** The same View instance created by factory

```kotlin
update = { spinner ->
    // This runs whenever selectedItem changes
    spinner.setSelection(selectedItem)
}
```

### Practical Implementation Pattern

The most important pattern to master:

```kotlin
@Composable
fun SpinnerExample() {
    val options = listOf("Option A", "Option B", "Option C")
    var selectedIndex by remember { mutableIntStateOf(0) }
    
    AndroidView(
        factory = { context ->
            //  Create and setup - called once
            Spinner(context).apply {
                adapter = ArrayAdapter(
                    context,
                    android.R.layout.simple_spinner_item,
                    options
                )
                //  DON'T set selection here - won't update on state changes
                onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                    override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                        selectedIndex = position  // Compose -> View communication
                    }
                    override fun onNothingSelected(parent: AdapterView<*>?) {}
                }
            }
        },
        update = { spinner ->
            //  Update state - called every recomposition
            if (spinner.selectedItemPosition != selectedIndex) {
                spinner.setSelection(selectedIndex)  // View -> Compose communication
            }
        },
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
    )
}
```

---

## <a name="examples"></a>3. PRACTICAL EXAMPLES

### Example 1: RatingBar Integration (Juice Tracker App)

**Problem:** Compose doesn't have a native RatingBar, but it's common in surveys/reviews.

```kotlin
@Composable
fun RatingBarView(
    rating: Float,
    onRatingChanged: (Float) -> Unit,
    modifier: Modifier = Modifier
) {
    AndroidView(
        factory = { context ->
            RatingBar(context).apply {
                numStars = 5
                stepSize = 0.5f
                setOnRatingBarChangeListener { ratingBar, r, fromUser ->
                    if (fromUser) {
                        onRatingChanged(r)  // Communicate rating back to Compose
                    }
                }
            }
        },
        update = { ratingBar ->
            if (ratingBar.rating != rating) {
                ratingBar.rating = rating  // Update View with Compose state
            }
        },
        modifier = modifier.fillMaxWidth().padding(16.dp)
    )
}

// Usage
@Composable
fun JuiceTrackerEntryDialog() {
    var rating by remember { mutableFloatStateOf(0f) }
    
    Column {
        Text("Rate this juice:")
        RatingBarView(
            rating = rating,
            onRatingChanged = { rating = it }
        )
        Text("Rating: $rating stars")
    }
}
```

### Example 2: Spinner for Color Selection

```kotlin
@Composable
fun ColorSpinner(
    selectedColor: String,
    onColorSelected: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    val colors = listOf("Red", "Green", "Blue", "Yellow", "Orange")
    
    AndroidView(
        factory = { context ->
            Spinner(context).apply {
                adapter = ArrayAdapter(
                    context,
                    android.R.layout.simple_spinner_item,
                    colors
                )
                onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                    override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                        onColorSelected(colors[position])
                    }
                    override fun onNothingSelected(parent: AdapterView<*>?) {}
                }
            }
        },
        update = { spinner ->
            val currentSelection = colors.indexOf(selectedColor)
            if (spinner.selectedItemPosition != currentSelection && currentSelection >= 0) {
                spinner.setSelection(currentSelection)
            }
        },
        modifier = modifier.fillMaxWidth().padding(8.dp)
    )
}
```

### Example 3: Google AdMob Banner Ad Integration

**Prerequisites:**
```gradle
dependencies {
    implementation 'com.google.android.gms:play-services-ads:20.6.0'
}
```

**Implementation:**

```kotlin
@Composable
fun GoogleAdBanner() {
    val context = LocalContext.current
    
    AndroidView(
        factory = { ctx ->
            AdView(ctx).apply {
                setAdSize(AdSize.BANNER)
                adUnitId = "ca-app-pub-3940256099942544/6300978111"  // Test Ad Unit
                loadAd(AdRequest.Builder().build())
            }
        },
        modifier = Modifier
            .fillMaxWidth()
            .height(50.dp)
    )
}

// Usage in your app
@Composable
fun HomeScreen() {
    Column(modifier = Modifier.fillMaxSize()) {
        GoogleAdBanner()
        
        // Rest of your content
        LazyColumn {
            items(juiceList) { juice ->
                JuiceListItem(juice)
            }
        }
    }
}
```

### Example 4: AndroidViewBinding with Pre-built Layouts

**Prerequisites:**
```gradle
dependencies {
    implementation 'androidx.compose.ui:ui-viewbinding:1.5.0'
}

android {
    buildFeatures {
        viewBinding true
    }
}
```

**XML Layout (res/layout/color_picker.xml):**
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">
    
    <Spinner
        android:id="@+id/colorSpinner"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
</LinearLayout>
```

**Compose Integration:**
```kotlin
@Composable
fun ColorPickerWithBinding(onColorSelected: (String) -> Unit) {
    AndroidViewBinding(ColorPickerBinding::inflate) {
        val colors = arrayOf("Red", "Blue", "Green")
        val adapter = ArrayAdapter(root.context, android.R.layout.simple_spinner_item, colors)
        
        colorSpinner.adapter = adapter
        colorSpinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                onColorSelected(colors[position])
            }
            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }
    }
}
```

---

## <a name="state-management"></a>4. STATE MANAGEMENT IN ANDROIDVIEW

### The Factory vs. Update Pattern (Critical Understanding)

**Problem:** Many developers set state-dependent properties in the `factory` lambda and wonder why they don't update.

**Root Cause:** `factory` is called **only once** during initialization. Any state read at that time is "captured" and never updated.

### Anti-Pattern ( DON'T DO THIS)

```kotlin
@Composable
fun BadRatingBar() {
    var rating by remember { mutableFloatStateOf(3f) }
    
    AndroidView(
        factory = { context ->
            RatingBar(context).apply {
                //  BUG: rating is read once here, never updates
                this.rating = rating
                
                setOnRatingBarChangeListener { ratingBar, r, fromUser ->
                    rating = r  // This works (View -> Compose)
                }
            }
        }
    )
}
```

When you change `rating` in Compose, the View won't reflect the change because the assignment in `factory` only happened once.

### Correct Pattern ( DO THIS)

```kotlin
@Composable
fun GoodRatingBar() {
    var rating by remember { mutableFloatStateOf(3f) }
    
    AndroidView(
        factory = { context ->
            RatingBar(context).apply {
                setOnRatingBarChangeListener { ratingBar, r, fromUser ->
                    if (fromUser) rating = r  // View -> Compose
                }
            }
        },
        update = { ratingBar ->
            //  CORRECT: Update called on every recomposition
            if (ratingBar.rating != rating) {
                ratingBar.rating = rating  // Compose -> View
            }
        }
    )
}
```

### Two-Way Communication Pattern

```kotlin
@Composable
fun TwoWaySpinner(
    selectedValue: String,
    onValueChanged: (String) -> Unit
) {
    val items = listOf("Item A", "Item B", "Item C")
    
    AndroidView(
        factory = { context ->
            Spinner(context).apply {
                adapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, items)
                
                // View -> Compose: User selects item
                onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                    override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                        onValueChanged(items[position])
                    }
                    override fun onNothingSelected(parent: AdapterView<*>?) {}
                }
            }
        },
        update = { spinner ->
            // Compose -> View: External state changes
            val currentIndex = items.indexOf(selectedValue)
            if (spinner.selectedItemPosition != currentIndex && currentIndex >= 0) {
                spinner.setSelection(currentIndex, false)  // false = don't trigger listener
            }
        }
    )
}
```

### Using State in Callbacks Safely

When you need to access state inside a listener/callback:

```kotlin
@Composable
fun SafeStateAccess() {
    var data by remember { mutableStateOf("Initial") }
    
    //  Use rememberUpdatedState to access latest state in callbacks
    val currentData by rememberUpdatedState(data)
    
    AndroidView(
        factory = { context ->
            Button(context).apply {
                text = "Click Me"
                setOnClickListener {
                    // Always uses latest value of data
                    println("Current data: ${currentData.value}")
                }
            }
        }
    )
}
```

---

## <a name="lifecycle"></a>5. LIFECYCLE MANAGEMENT

### ViewCompositionStrategy Explained

When integrating Compose into traditional Views (via ComposeView), you need to manage when the Composition is disposed.

```kotlin
composeView.setViewCompositionStrategy(strategy)
```

### Available Strategies

#### 1. **DisposeOnDetachedFromWindow** (Deprecated)
-  No longer recommended
- Was used for simple cases where View is added/removed

#### 2. **DisposeOnDetachedFromWindowOrReleasedFromPool** (Default)
- Disposes when View is detached from window
- OR when released from a reusable pool (like RecyclerView)
- **Use when:** ComposeView in RecyclerView or standalone View hierarchy

```kotlin
composeView.setViewCompositionStrategy(
    ViewCompositionStrategy.DisposeOnDetachedFromWindowOrReleasedFromPool
)
```

#### 3. **DisposeOnLifecycleDestroyed**
- Disposes when a specific Lifecycle is destroyed
- Requires knowing the LifecycleOwner upfront
- **Use when:** ComposeView in an Activity/Fragment with known Lifecycle

```kotlin
val lifecycle = /* some LifecycleOwner */.lifecycle
composeView.setViewCompositionStrategy(
    ViewCompositionStrategy.DisposeOnLifecycleDestroyed(lifecycle)
)
```

#### 4. **DisposeOnViewTreeLifecycleDestroyed** (Most Common for Fragments)
- Automatically discovers the LifecycleOwner from the window's ViewTree
- Disposes when that Lifecycle is destroyed
- **Best for:** Fragment layouts where lifecycle is not explicitly known
- **Why not DisposeOnLifecycleDestroyed for Fragments?** 
  - Fragments have TWO lifecycles: the Fragment's and the Fragment's View's
  - The View's lifecycle may be destroyed before the Fragment's (e.g., navigation)
  - Using ViewTree strategy ensures proper cleanup when the View is destroyed

```kotlin
composeView.setViewCompositionStrategy(
    ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed
)
```

### Real-World Examples

#### In a Fragment (with ViewBinding)
```kotlin
class MyFragment : Fragment() {
    private var _binding: MyFragmentBinding? = null
    private val binding get() = _binding!!
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = MyFragmentBinding.inflate(inflater, container, false)
        
        binding.composeView.apply {
            //  Use ViewTree strategy for fragments
            setViewCompositionStrategy(
                ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed
            )
            setContent {
                MaterialTheme {
                    MyComposableContent()
                }
            }
        }
        
        return binding.root
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
```

#### In a RecyclerView Adapter
```kotlin
class ComposableViewHolder(
    private val composeView: ComposeView
) : RecyclerView.ViewHolder(composeView) {
    
    fun bind(item: Item) {
        composeView.apply {
            //  Use DetachedFromWindowOrReleasedFromPool for RecyclerView
            setViewCompositionStrategy(
                ViewCompositionStrategy.DisposeOnDetachedFromWindowOrReleasedFromPool
            )
            setContent {
                MaterialTheme {
                    ItemCard(item)
                }
            }
        }
    }
}
```

### Lifecycle-Aware AndroidView

When using AndroidView, some legacy Views (like MapView) require explicit lifecycle management:

```kotlin
@Composable
fun LifecycleAwareMapView() {
    val lifecycleOwner = LocalLifecycleOwner.current
    
    AndroidView(
        factory = { context ->
            MapView(context).apply {
                // Register for lifecycle events
                lifecycleOwner.lifecycle.addObserver(object : DefaultLifecycleObserver {
                    override fun onResume(owner: LifecycleOwner) {
                        this@apply.onResume()
                    }
                    override fun onPause(owner: LifecycleOwner) {
                        this@apply.onPause()
                    }
                    override fun onDestroy(owner: LifecycleOwner) {
                        this@apply.onDestroy()
                    }
                })
            }
        },
        modifier = Modifier.fillMaxSize()
    )
}
```

---

## <a name="faq"></a>6. FAQ & BEST PRACTICES

### Q1: When should I use AndroidView vs. creating a native Composable?

**A:** Use AndroidView when:
-  No Compose equivalent exists (AdView, RatingBar, MapView)
-  You have proven custom Views with complex logic
-  Migration happens gradually over time

Prefer native Composables when:
-  A Compose equivalent exists
-  You're building new features
-  You need better animation and state integration

### Q2: Why does my View not respond to state changes?

**A:** Most likely, you're setting properties in `factory` instead of `update`:

```kotlin
//  Wrong - only happens once
factory = { context ->
    MyView(context).apply {
        this.selectedValue = state  // Only set once!
    }
}

//  Correct - happens on every recomposition
update = { view ->
    view.selectedValue = state  // Updates every time
}
```

### Q3: How do I prevent unnecessary updates in the update lambda?

**A:** Check the current value before updating:

```kotlin
update = { view ->
    //  Good: Only update if needed
    if (view.rating != rating) {
        view.rating = rating
    }
}
```

### Q4: My AndroidView is not visible. What's wrong?

**Common causes:**
1. **No size specified** → Add `modifier = Modifier.fillMaxWidth().height(100.dp)`
2. **Layout params incorrect** → Ensure `layoutParams` are set correctly
3. **Parent layout issue** → Wrap in a Box or Column with explicit sizing

```kotlin
//  Correct sizing
Box(modifier = Modifier.fillMaxWidth().height(200.dp)) {
    AndroidView(
        factory = { /* ... */ },
        modifier = Modifier.fillMaxSize()
    )
}
```

### Q5: How do I handle listener callbacks that need access to Compose state?

**A:** Use `rememberUpdatedState`:

```kotlin
@Composable
fun ListenerWithState() {
    var counter by remember { mutableIntStateOf(0) }
    val currentCounter by rememberUpdatedState(counter)
    
    AndroidView(
        factory = { context ->
            Button(context).apply {
                setOnClickListener {
                    //  Always has latest counter value
                    println("Counter is now: ${currentCounter.value}")
                }
            }
        }
    )
}
```

### Q6: Should I dispose resources in AndroidView?

**A:** Use `DisposableEffect` for cleanup:

```kotlin
@Composable
fun AndroidViewWithCleanup() {
    val context = LocalContext.current
    
    AndroidView(
        factory = { ctx ->
            MyView(ctx).apply {
                // Initialize expensive resources
                startListening()
            }
        },
        modifier = Modifier.fillMaxSize()
    )
    
    DisposableEffect(Unit) {
        onDispose {
            // Cleanup when leaving composition
            // Note: View instance may not be accessible here
            // Better approach: manage cleanup inside the View or factory lambda
        }
    }
}
```

### Best Practice Checklist

- [ ] Use `factory` only for View creation and setup
- [ ] Use `update` for all state-dependent property updates
- [ ] Check for value changes before updating in `update` block
- [ ] Use `rememberUpdatedState` when passing state to callbacks
- [ ] Set explicit size via `modifier` (don't rely on wrap_content)
- [ ] Use appropriate `ViewCompositionStrategy` for ComposeView
- [ ] Test lifecycle behavior (rotation, navigation)
- [ ] Consider memory leaks from long-lived listeners

---

## <a name="use-cases"></a>7. COMMON USE CASES & SOLUTIONS

### Use Case 1: Implementing RatingBar in Juice Tracker App

**Context:** Users need to rate juice drinks with stars. Compose doesn't have RatingBar.

```kotlin
@Composable
fun RatingInput(
    rating: Float,
    onRatingChanged: (Float) -> Unit,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier) {
        Text("Rate this juice", style = MaterialTheme.typography.bodyLarge)
        
        AndroidView(
            factory = { context ->
                RatingBar(context).apply {
                    numStars = 5
                    stepSize = 1f
                    setOnRatingBarChangeListener { _, r, fromUser ->
                        if (fromUser) {
                            onRatingChanged(r)
                        }
                    }
                }
            },
            update = { ratingBar ->
                if (ratingBar.rating != rating) {
                    ratingBar.rating = rating
                }
            },
            modifier = Modifier
                .padding(vertical = 16.dp)
                .wrapContentSize(Alignment.Center)
        )
        
        Text("${rating.toInt()} stars")
    }
}

// In your entry dialog
@Composable
fun JuiceEntryDialog(onSave: (Juice) -> Unit) {
    var rating by remember { mutableFloatStateOf(0f) }
    
    AlertDialog(
        onDismissRequest = { /* ... */ },
        title = { Text("Add Juice") },
        text = {
            Column {
                // ... other fields
                RatingInput(
                    rating = rating,
                    onRatingChanged = { rating = it }
                )
            }
        },
        confirmButton = {
            Button(onClick = {
                val newJuice = Juice(rating = rating.toInt())
                onSave(newJuice)
            })
        }
    )
}
```

### Use Case 2: Color Spinner for Juice Tracking

**Context:** Users select juice color from a dropdown.

```kotlin
@Composable
fun ColorSpinnerField(
    label: String,
    selectedColor: JuiceColor,
    onColorSelected: (JuiceColor) -> Unit,
    modifier: Modifier = Modifier
) {
    val colors = JuiceColor.values().toList()
    val colorNames = colors.map { it.displayName }
    
    Column(modifier = modifier) {
        Text(label)
        
        AndroidView(
            factory = { context ->
                Spinner(context).apply {
                    adapter = ArrayAdapter(
                        context,
                        android.R.layout.simple_spinner_item,
                        colorNames
                    )
                    onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                        override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                            onColorSelected(colors[position])
                        }
                        override fun onNothingSelected(parent: AdapterView<*>?) {}
                    }
                }
            },
            update = { spinner ->
                val currentIndex = colors.indexOf(selectedColor)
                if (spinner.selectedItemPosition != currentIndex) {
                    spinner.setSelection(currentIndex, false)
                }
            },
            modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp)
        )
    }
}

// In entry dialog
var selectedColor by remember { mutableStateOf(JuiceColor.ORANGE) }

ColorSpinnerField(
    label = "Juice Color",
    selectedColor = selectedColor,
    onColorSelected = { selectedColor = it }
)
```

### Use Case 3: Ad Banner at Top of List

**Context:** Show banner ads above the juice tracker list.

```kotlin
@Composable
fun JuiceTrackerList(juiceList: List<Juice>) {
    Column(modifier = Modifier.fillMaxSize()) {
        // Ad banner at top
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(60.dp)
                .background(Color.LightGray)
        ) {
            GoogleAdBanner()
        }
        
        // List content
        LazyColumn(modifier = Modifier.weight(1f)) {
            items(juiceList) { juice ->
                JuiceListItem(juice)
            }
        }
    }
}

@Composable
fun GoogleAdBanner() {
    AndroidView(
        factory = { context ->
            AdView(context).apply {
                setAdSize(AdSize.BANNER)
                adUnitId = "ca-app-pub-3940256099942544/6300978111"
                
                val adRequest = AdRequest.Builder().build()
                loadAd(adRequest)
            }
        },
        modifier = Modifier
            .fillMaxWidth()
            .height(50.dp),
    )
}
```

### Use Case 4: Custom View Reuse

**Context:** You have a complex custom View and want to use it in Compose.

```kotlin
@Composable
fun CustomChartView(data: List<ChartDataPoint>, modifier: Modifier = Modifier) {
    var dataPoints by remember { mutableStateOf(data) }
    
    AndroidView(
        factory = { context ->
            ChartView(context).apply {
                setChartDataPoints(dataPoints)
            }
        },
        update = { chartView ->
            chartView.setChartDataPoints(dataPoints)
        },
        modifier = modifier
            .fillMaxWidth()
            .height(300.dp)
    )
}

// Usage
val myData = remember { mutableStateOf(listOf(/* ... */)) }
CustomChartView(
    data = myData.value,
    modifier = Modifier.padding(16.dp)
)
```

### Use Case 5: Migration Strategy

**Context:** You're gradually migrating a View-based app to Compose.

```kotlin
// Phase 1: Wrap legacy screens
class LegacyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val view = inflater.inflate(R.layout.legacy_layout, null)
        
        // Add a Compose section
        val composeView = view.findViewById<ComposeView>(R.id.compose_section)
        composeView.apply {
            setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnDetachedFromWindowOrReleasedFromPool)
            setContent {
                MyNewComposableFeature()
            }
        }
        
        setContentView(view)
    }
}

// Phase 2: Create Compose screens with AndroidView for legacy components
@Composable
fun NewScreen() {
    Column {
        // New Compose UI
        Text("Welcome to Compose!")
        
        // Still using legacy components
        AndroidView(
            factory = { LegacyCustomView(it) }
        )
    }
}

// Phase 3: Full Compose migration
class FullComposeActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyComposableApp()
        }
    }
}
```

---

## Quick Reference: Syntax Cheatsheet

```kotlin
// Basic AndroidView
AndroidView(
    factory = { context -> MyView(context) },
    modifier = Modifier.fillMaxWidth().height(100.dp)
)

// With state management
AndroidView(
    factory = { context ->
        MyView(context).apply {
            setListener { value -> onStateChanged(value) }
        }
    },
    update = { view ->
        view.state = currentState
    }
)

// With binding
AndroidViewBinding(MyLayoutBinding::inflate) {
    myView.text = "Hello"
}

// ComposeView in Fragment
binding.composeView.apply {
    setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
    setContent {
        MyComposable()
    }
}

// Lifecycle-aware
val lifecycleOwner = LocalLifecycleOwner.current
// Use in DisposableEffect or effects...
```

---
# Views in Compose - Quick Reference & Revision Notes

## Core Concepts at a Glance

### What is View Interop?
Seamlessly integrate traditional Android Views into Jetpack Compose applications and vice versa. Necessary because not all UI components have Compose equivalents (AdView, RatingBar, custom Views, etc.).

---

## The AndroidView Composable

### Signature
```kotlin
@Composable
fun <T : View> AndroidView(
    factory: (Context) -> T,
    modifier: Modifier = Modifier,
    update: (T) -> Unit = NoOpUpdate
)
```

### Parameters Comparison

| Parameter | Called | Purpose | Key Points |
|-----------|--------|---------|------------|
| **factory** | Once at creation | Create & initialize View | Static setup, no state |
| **update** | Every recomposition | Update View with Compose state | Called repeatedly |
| **modifier** | Standard | Size, padding, alignment | Works like any Composable |

### The Golden Rule
```
 WRONG: Set state in factory
factory = { MyView(it).apply { value = state } }  // Only happens once!

 RIGHT: Update state in update block
update = { view -> view.value = state }  // Happens on every recomposition
```

---

## Factory vs. Update Pattern (CRITICAL)

### The Problem
```kotlin
@Composable
fun BadExample() {
    var rating by remember { mutableFloatStateOf(3f) }
    
    AndroidView(
        factory = { context ->
            RatingBar(context).apply {
                this.rating = rating  //  Only runs ONCE
            }
        }
    )
    // When rating changes in Compose, the View doesn't update!
}
```

### The Solution
```kotlin
@Composable
fun GoodExample() {
    var rating by remember { mutableFloatStateOf(3f) }
    
    AndroidView(
        factory = { context ->
            RatingBar(context).apply {
                //  Just create it
            }
        },
        update = { ratingBar ->
            //  Update runs every recomposition
            if (ratingBar.rating != rating) {
                ratingBar.rating = rating
            }
        }
    )
}
```

---

## Two-Way Communication Pattern

### View → Compose (User interaction)
```kotlin
setOnClickListener { 
    composeState = newValue  // Send data to Compose
}
```

### Compose → View (State updates)
```kotlin
update = { view ->
    view.property = composeState  // Send state to View
}
```

### Complete Example
```kotlin
@Composable
fun Spinner(selected: String, onSelect: (String) -> Unit) {
    val items = listOf("A", "B", "C")
    
    AndroidView(
        factory = { context ->
            Spinner(context).apply {
                adapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, items)
                // View → Compose
                onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                    override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                        onSelect(items[position])
                    }
                    override fun onNothingSelected(parent: AdapterView<*>?) {}
                }
            }
        },
        update = { spinner ->
            // Compose → View
            val index = items.indexOf(selected)
            if (spinner.selectedItemPosition != index && index >= 0) {
                spinner.setSelection(index, false)
            }
        }
    )
}
```

---

## Common APIs Overview

| API | Use Case | Example |
|-----|----------|---------|
| **AndroidView** | Wrap traditional View | `AndroidView(factory = { Spinner(it) })` |
| **ComposeView** | Add Compose to View-based layout | `setContent { MyComposable() }` |
| **AndroidViewBinding** | Use XML layout with binding | `AndroidViewBinding(MyLayoutBinding::inflate)` |
| **AndroidFragment** | Add Fragment to Compose | `AndroidFragment()` |

---

## ViewCompositionStrategy (For ComposeView)

### When to Use Which Strategy?

| Strategy | Used For | When to Choose |
|----------|----------|---|
| **DisposeOnDetachedFromWindowOrReleasedFromPool** | RecyclerView, standalone | Default. View can be reused. |
| **DisposeOnLifecycleDestroyed** | Activity/Fragment with known Lifecycle | When you have explicit Lifecycle reference |
| **DisposeOnViewTreeLifecycleDestroyed** | Fragment (recommended) | Most common. Auto-discovers Lifecycle from window. |

### Why DisposeOnViewTreeLifecycleDestroyed for Fragments?
Fragments have TWO lifecycles:
- Fragment's lifecycle
- Fragment's View's lifecycle

The View can be destroyed before the Fragment (e.g., navigation). Using ViewTree strategy ensures cleanup when the View is destroyed.

```kotlin
composeView.apply {
    setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
    setContent { MyComposable() }
}
```

---

## Handling State in Callbacks

### Problem: Stale State in Listeners
```kotlin
var counter by remember { mutableIntStateOf(0) }

AndroidView(
    factory = { context ->
        Button(context).apply {
            setOnClickListener {
                //  counter here is captured at factory time!
                println(counter)  // Always prints 0
            }
        }
    }
)
```

### Solution: rememberUpdatedState
```kotlin
var counter by remember { mutableIntStateOf(0) }
val currentCounter by rememberUpdatedState(counter)

AndroidView(
    factory = { context ->
        Button(context).apply {
            setOnClickListener {
                //  Always has latest value
                println(currentCounter.value)  // Always current
            }
        }
    }
)
```

---

## Real-World Examples Quick Reference

### RatingBar
```kotlin
@Composable
fun RatingBar(rating: Float, onRatingChanged: (Float) -> Unit) {
    AndroidView(
        factory = { context ->
            RatingBar(context).apply {
                numStars = 5
                setOnRatingBarChangeListener { _, r, fromUser ->
                    if (fromUser) onRatingChanged(r)
                }
            }
        },
        update = { view ->
            if (view.rating != rating) view.rating = rating
        }
    )
}
```

### Spinner
```kotlin
@Composable
fun ColorSpinner(selected: String, onSelect: (String) -> Unit) {
    val options = listOf("Red", "Green", "Blue")
    
    AndroidView(
        factory = { context ->
            Spinner(context).apply {
                adapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, options)
                onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                    override fun onItemSelected(p: AdapterView<*>?, v: View?, pos: Int, id: Long) {
                        onSelect(options[pos])
                    }
                    override fun onNothingSelected(p: AdapterView<*>?) {}
                }
            }
        },
        update = { spinner ->
            val idx = options.indexOf(selected)
            if (spinner.selectedItemPosition != idx && idx >= 0) {
                spinner.setSelection(idx, false)
            }
        }
    )
}
```

### AdView (Google Ads)
```kotlin
@Composable
fun GoogleAdBanner() {
    AndroidView(
        factory = { context ->
            AdView(context).apply {
                setAdSize(AdSize.BANNER)
                adUnitId = "ca-app-pub-3940256099942544/6300978111"  // Test ID
                loadAd(AdRequest.Builder().build())
            }
        },
        modifier = Modifier.fillMaxWidth().height(50.dp)
    )
}
```

---

## Debugging Checklist

**View not showing?**
- [ ] Did you set explicit size? (modifier = Modifier.width().height())
- [ ] Is the View created in factory?
- [ ] Is parent layout visible?

**State not updating?**
- [ ] Are you setting state in factory () instead of update ()?
- [ ] Did you add the update lambda?
- [ ] Are you checking for changes before updating?

**Listener not working?**
- [ ] Is the listener set in factory?
- [ ] Do you need rememberUpdatedState for current state access?
- [ ] Is the callback function signature correct?

**Lifecycle issues?**
- [ ] Did you choose correct ViewCompositionStrategy?
- [ ] Does the View need explicit lifecycle management (MapView)?
- [ ] Test rotation and navigation!

---

## Key Takeaways for Exam/Interview

1. **View Interop = Bridge between Views and Compose**
   - Use when Compose doesn't have equivalent (AdView, RatingBar)
   - Use for gradual migration strategies

2. **AndroidView has three parameters**
   - factory: Create once
   - update: Run every recomposition
   - modifier: Size and position

3. **Factory is called ONCE**
   - Don't set state-dependent properties there
   - Use update block for all state updates
   - CRITICAL: This is the #1 mistake developers make

4. **Two-way communication**
   - View → Compose: Via callbacks in factory (onClickListener, etc.)
   - Compose → View: Via update block

5. **ViewCompositionStrategy matters**
   - Use DisposeOnViewTreeLifecycleDestroyed for Fragments
   - Use DisposeOnDetachedFromWindowOrReleasedFromPool for RecyclerView
   - Prevents memory leaks and resource issues

6. **State management requires rememberUpdatedState**
   - When callbacks need access to current state
   - Without it, they capture old values

---

## Code Template for Copy-Paste

```kotlin
@Composable
fun MyAndroidViewWrapper(
    state: String,
    onStateChange: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    AndroidView(
        factory = { context ->
            //  Create and setup - called ONCE
            MyView(context).apply {
                setListener { newValue ->
                    // View → Compose
                    onStateChange(newValue)
                }
            }
        },
        update = { view ->
            //  Update based on state - called EVERY RECOMPOSITION
            if (view.state != state) {
                view.state = state  // Compose → View
            }
        },
        modifier = modifier
            .fillMaxWidth()
            .height(100.dp)
            .padding(16.dp)
    )
}
```

---

## Study Tips

**To master View Interop:**

1. **Build the Juice Tracker app** following the codelab
   - Implement RatingBar (AndroidView wrapper)
   - Implement Color Spinner (state management)
   - Integrate AdView (no update needed)

2. **Practice the factory/update pattern**
   - Write 5 different AndroidView implementations
   - Make common mistakes intentionally, then fix them
   - Understand WHY factory is called once

3. **Test lifecycle behavior**
   - Rotate device with View Interop
   - Navigate between screens
   - Watch for memory leaks

4. **Create your own wrapper composables**
   - MapView
   - Custom Analytics View
   - Barcode Scanner
   
5. **Review state management**
   - rememberUpdatedState
   - DisposableEffect
   - Effect timing

---
# View Interoperability in Compose - Advanced FAQs & Troubleshooting

## Frequently Asked Questions (FAQ)

---

## 1. GENERAL QUESTIONS

### Q: What is the difference between AndroidView and ComposeView?

**A:**
| Aspect | AndroidView | ComposeView |
|--------|------------|-----------|
| **Purpose** | Embed traditional Views IN Compose | Embed Compose IN traditional Views |
| **Direction** | Views → Compose | Compose → Views |
| **Used in** | Compose-first apps | View-first/legacy apps |
| **Example** | `AndroidView(factory = { Spinner(it) })` | `binding.composeView.setContent { }` |

**When to use AndroidView:**
- You're building a Compose app
- You need a View component that doesn't exist in Compose
- You're gradually migrating to Compose

**When to use ComposeView:**
- You're in a View-based Activity/Fragment
- You want to add new Compose UI features
- You're doing a phased migration

---

### Q: Should I always use AndroidView instead of building a Compose equivalent?

**A:** No. Use this decision matrix:

```
Does Compose have an equivalent?
├─ YES
│  ├─ Use Compose version (better performance, animations, integration)
│  └─ Except: You already have proven custom View logic
└─ NO
   └─ Use AndroidView wrapping
```

**Examples:**
-  DON'T use `AndroidView(Spinner)` → Use `ExposedDropdownMenuBox`
-  DO use `AndroidView(RatingBar)` → No Compose equivalent exists
-  DO use `AndroidView(AdView)` → No Compose equivalent exists
-  DON'T use `AndroidView(Button)` → Use Compose `Button`

---

### Q: What are the performance implications of AndroidView?

**A:** 
- **Cons:**
  - Android View system has overhead (layout passes, drawing)
  - Bridge cost between Compose and View hierarchies
  - May skip some Compose optimizations (Skiko rendering, recomposition scope)
  - More memory if not properly disposed

- **Pros:**
  - Negligible if only a few AndroidViews
  - Better than complete rewrite to Compose
  - Gradual migration allows phased optimization

**Best practice:** Use AndroidView for necessary components, not as a crutch.

---

## 2. STATE MANAGEMENT & UPDATES

### Q: Why does the View not update when Compose state changes?

**A:** 99% of the time: **You're setting properties in factory instead of update.**

```kotlin
//  This doesn't work
AndroidView(
    factory = { context ->
        MyView(context).apply {
            value = myState  // Only runs once!
        }
    }
)

//  This works
AndroidView(
    factory = { context -> MyView(context) },
    update = { view -> view.value = myState }  // Runs on every recomposition
)
```

**Why?**
- `factory` is called once during composition creation
- It captures the state value at that moment
- When state changes, factory doesn't run again
- Only `update` runs on recomposition

---

### Q: How do I prevent unnecessary updates in the update lambda?

**A:** Check before updating:

```kotlin
update = { view ->
    //  Good: Only update if necessary
    if (view.currentValue != newValue) {
        view.currentValue = newValue
    }
}

// OR use a mutable state that tracks previous value
update = { view ->
    val previous = remember(newValue) { newValue }
    if (view.value != previous) {
        view.value = previous
    }
}
```

**Why:**
- Prevents unnecessary View redraws
- Avoids triggering View listeners again (preventing state loops)
- Better performance

---

### Q: How do I access current state in a callback/listener set in factory?

**A:** Use `rememberUpdatedState`:

```kotlin
@Composable
fun MyComponent(state: String) {
    val currentState by rememberUpdatedState(state)
    
    AndroidView(
        factory = { context ->
            MyView(context).apply {
                setOnEventListener {
                    //  Always has latest state
                    println("Current: ${currentState.value}")
                    //  vs just using state captures old value
                }
            }
        }
    )
}
```

**Why rememberUpdatedState is needed:**
- Callback is created once in factory
- It captures variable at that time
- Without rememberUpdatedState, it would always use the original value
- rememberUpdatedState returns a State object that updates without recreating callbacks

---

### Q: How do I handle two-way binding (View updates Compose, Compose updates View)?

**A:** Implement both directions:

```kotlin
@Composable
fun TwoWayView(
    value: String,
    onValueChange: (String) -> Unit
) {
    AndroidView(
        factory = { context ->
            MyView(context).apply {
                // Direction 1: View → Compose
                setOnChangeListener { newValue ->
                    onValueChange(newValue)
                }
            }
        },
        update = { view ->
            // Direction 2: Compose → View
            if (view.getValue() != value) {
                view.setValue(value)
            }
        }
    )
}
```

**Usage:**
```kotlin
var selectedValue by remember { mutableStateOf("A") }

TwoWayView(
    value = selectedValue,
    onValueChange = { newValue ->
        selectedValue = newValue  // Update Compose state when View changes
    }
)
```

---

## 3. LIFECYCLE & COMPOSITION MANAGEMENT

### Q: What's the difference between the ViewCompositionStrategy options?

**A:**

| Strategy | Disposes When | Use Case | Risk |
|----------|---------------|----------|------|
| **DisposeOnDetachedFromWindow** | View detached | Simple standalone Views | Deprecated |
| **DisposeOnDetachedFromWindowOrReleasedFromPool** | Detached OR pool released | RecyclerView items | Default, safest for reusable Views |
| **DisposeOnLifecycleDestroyed** | Specific Lifecycle destroyed | Activity/Fragment with known Lifecycle | Manual Lifecycle management |
| **DisposeOnViewTreeLifecycleDestroyed** | Window's ViewTree Lifecycle destroyed | Fragment (auto-discovers Lifecycle) | Most appropriate for Fragments |

**Decision tree:**
```
Are you using ComposeView in a Fragment?
├─ YES → Use DisposeOnViewTreeLifecycleDestroyed
└─ NO
   └─ Is it in a RecyclerView?
      ├─ YES → Use DisposeOnDetachedFromWindowOrReleasedFromPool (default)
      └─ NO
         └─ Do you have explicit Lifecycle reference?
            ├─ YES → Use DisposeOnLifecycleDestroyed(yourLifecycle)
            └─ NO → Use DisposeOnViewTreeLifecycleDestroyed
```

---

### Q: Why does my View's state disappear after navigation?

**A:** Likely causes:

1. **Wrong ViewCompositionStrategy**
   ```kotlin
   //  Wrong for Fragment
   setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnDetachedFromWindow)
   
   //  Right for Fragment
   setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
   ```

2. **View not preserving state across Lifecycle**
   ```kotlin
   // If your View has state, save it
   override fun onSaveInstanceState(): Parcelable {
       return Bundle().apply {
           putString("myState", value)
           putParcelable("parent", super.onSaveInstanceState())
       }
   }
   ```

3. **Recreating the View in factory on every recomposition**
   ```kotlin
   //  Factory gets called multiple times
   AndroidView(factory = { MyView(it) })
   
   //  View is reused
   var viewInstance: MyView? = null
   AndroidView(
       factory = { context ->
           if (viewInstance == null) viewInstance = MyView(context)
           viewInstance!!
       }
   )
   ```

---

### Q: Do I need to handle lifecycle events for AndroidView?

**A:** Only if the underlying View requires it (MapView, MediaView, etc.):

```kotlin
@Composable
fun LifecycleAwareMap() {
    val lifecycleOwner = LocalLifecycleOwner.current
    
    AndroidView(
        factory = { context ->
            MapView(context).apply {
                // Register for lifecycle events
                lifecycleOwner.lifecycle.addObserver(
                    object : DefaultLifecycleObserver {
                        override fun onCreate(owner: LifecycleOwner) {
                            this@apply.onCreate(Bundle())
                        }
                        override fun onResume(owner: LifecycleOwner) {
                            this@apply.onResume()
                        }
                        override fun onPause(owner: LifecycleOwner) {
                            this@apply.onPause()
                        }
                        override fun onDestroy(owner: LifecycleOwner) {
                            this@apply.onDestroy()
                        }
                    }
                )
            }
        },
        modifier = Modifier.fillMaxSize()
    )
}
```

**Views that typically need lifecycle management:**
- MapView (Google Maps)
- MediaPlayer / ExoPlayer views
- WebView
- Custom Views with resource management

**Views that don't:**
- Spinner, EditText, Button (standard Views)
- RatingBar, ProgressBar
- AdView (Google Ads handles it)

---

## 4. LISTENERS & EVENT HANDLING

### Q: How do I set up listeners correctly in AndroidView?

**A:** Best practice:

```kotlin
@Composable
fun ViewWithListener(onEvent: (String) -> Unit) {
    // Remember the callback to maintain reference
    val currentCallback by rememberUpdatedState(onEvent)
    
    AndroidView(
        factory = { context ->
            MyView(context).apply {
                // Set listener in factory - it's created once
                setMyListener { event ->
                    // Always call current callback
                    currentCallback.value(event)
                }
            }
        }
    )
}
```

**Why this pattern:**
- Listener created once (efficient)
- Always calls current callback (has latest state)
- No listener recreation on recomposition

---

### Q: My listener callback doesn't have access to current state!

**A:** Use `rememberUpdatedState`:

```kotlin
//  Old state captured
@Composable
fun BadListener(clickCount: Int) {
    AndroidView(
        factory = { context ->
            Button(context).apply {
                setOnClickListener {
                    // clickCount here is always initial value!
                    println(clickCount)
                }
            }
        }
    )
}

//  Always latest state
@Composable
fun GoodListener(clickCount: Int) {
    val currentCount by rememberUpdatedState(clickCount)
    
    AndroidView(
        factory = { context ->
            Button(context).apply {
                setOnClickListener {
                    // currentCount.value is always latest
                    println(currentCount.value)
                }
            }
        }
    )
}
```

---

## 5. SIZE & LAYOUT

### Q: My AndroidView is not visible / doesn't have the right size

**A:** Most common issue: **Not setting explicit size**

```kotlin
//  View might not be visible
AndroidView(factory = { Spinner(it) })

//  Explicit size
AndroidView(
    factory = { Spinner(it) },
    modifier = Modifier
        .fillMaxWidth()
        .height(50.dp)
)

//  Or wrap in Box with size
Box(modifier = Modifier.fillMaxWidth().height(50.dp)) {
    AndroidView(
        factory = { Spinner(it) },
        modifier = Modifier.fillMaxSize()  // Fill the Box
    )
}
```

**Why:**
- Compose needs explicit sizing
- Views with wrap_content might not display properly
- Parent layout must have size for child to render

---

### Q: How do I control padding and margins of AndroidView?

**A:** Use standard Modifier functions:

```kotlin
AndroidView(
    factory = { /* ... */ },
    modifier = Modifier
        .padding(16.dp)           // Internal padding
        .fillMaxWidth()           // Width
        .height(100.dp)          // Height
        .clip(RoundedCornerShape(8.dp))  // Border radius
        .border(1.dp, Color.Gray)  // Border
)
```

**Compose Modifiers work with AndroidView:**
- `padding()` - Internal spacing
- `size()`, `width()`, `height()` - Dimensions
- `fillMaxWidth()`, `fillMaxSize()` - Stretch to parent
- `clip()`, `border()` - Visual styling
- `alpha()` - Transparency
- `scale()`, `rotate()` - Transforms

---

## 6. COMPOSE IN VIEWS (ComposeView)

### Q: How do I properly set up ComposeView in a Fragment?

**A:** Complete example:

```kotlin
class MyFragment : Fragment() {
    private var _binding: FragmentMyBinding? = null
    private val binding get() = _binding!!
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentMyBinding.inflate(inflater, container, false)
        
        binding.composeView.apply {
            //  Must set strategy BEFORE setContent
            setViewCompositionStrategy(
                ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed
            )
            
            // Now set Compose content
            setContent {
                MaterialTheme {
                    MyComposableScreen()
                }
            }
        }
        
        return binding.root
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null  // Clean up binding
    }
}
```

**XML layout (fragment_my.xml):**
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <androidx.compose.ui.platform.ComposeView
        android:id="@+id/compose_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</LinearLayout>
```

---

### Q: How do I add Compose to a View-based Activity?

**A:** Two approaches:

**Approach 1: Full Compose Activity (Recommended for new Activities)**
```kotlin
class MyActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MaterialTheme {
                MyComposableScreen()
            }
        }
    }
}
```

**Approach 2: Compose in existing View hierarchy**
```kotlin
class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        val layout = LinearLayout(this).apply {
            orientation = LinearLayout.VERTICAL
        }
        
        // Add traditional View
        layout.addView(
            TextView(this).apply { text = "Traditional View" }
        )
        
        // Add Compose view
        layout.addView(
            ComposeView(this).apply {
                setViewCompositionStrategy(
                    ViewCompositionStrategy.DisposeOnDetachedFromWindowOrReleasedFromPool
                )
                setContent {
                    Text("Compose View")
                }
            }
        )
        
        setContentView(layout)
    }
}
```

---

## 7. MIGRATION & GRADUAL ADOPTION

### Q: I have a View-based app. How do I migrate to Compose?

**A:** Four-phase approach:

**Phase 1: Add Compose to existing screens**
```kotlin
// Fragment with View-based UI + Compose section
binding.composeViewNewFeature.apply {
    setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
    setContent { NewComposeFeature() }
}
```

**Phase 2: Create new screens in Compose**
```kotlin
// New Activity entirely in Compose
class NewFeatureActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent { NewFeatureScreen() }
    }
}
```

**Phase 3: Convert existing screens**
```kotlin
// Gradually convert Views to Composables
// Use AndroidView where Compose equivalents don't exist
@Composable
fun ConvertedScreen() {
    Column {
        // Compose UI for parts you've converted
        Text("New Compose Title")
        
        // Legacy Views still used
        AndroidView(factory = { LegacyCustomView(it) })
    }
}
```

**Phase 4: Complete migration**
- All screens in Compose
- AndroidView only for necessary Views
- Deprecate ComposeView usage

---

### Q: How do I share state during migration?

**A:** Use shared ViewModels:

```kotlin
// Fragment with traditional View
class MyFragment : Fragment() {
    private val viewModel: SharedViewModel by viewModels()
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // View observes ViewModel
        viewModel.uiState.observe(viewLifecycleOwner) { state ->
            updateUI(state)
        }
        
        // Compose section also uses same ViewModel
        binding.composeView.apply {
            setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
            setContent {
                ComposePart(viewModel)
            }
        }
    }
}

@Composable
fun ComposePart(viewModel: SharedViewModel) {
    val uiState by viewModel.uiState.collectAsState()
    // Use shared state
}
```

---

## 8. TESTING

### Q: How do I test AndroidView in Compose?

**A:** Use `createComposeRule()`:

```kotlin
class MyAndroidViewTest {
    @get:Rule
    val composeTestRule = createComposeRule()
    
    @Test
    fun androidViewDisplaysCorrectly() {
        composeTestRule.setContent {
            MyAndroidViewComponent(
                value = "Test Value",
                onValueChange = {}
            )
        }
        
        // Find the View
        composeTestRule.onRoot().printToLog("MyTest")
        
        // Alternative: Use onNodeWithText if View renders text
        composeTestRule.onNodeWithText("Test Value").assertIsDisplayed()
    }
    
    @Test
    fun androidViewCallsCallback() {
        var callbackValue = ""
        
        composeTestRule.setContent {
            MyAndroidViewComponent(
                value = "Initial",
                onValueChange = { callbackValue = it }
            )
        }
        
        // Simulate View change
        composeTestRule.runOnIdle {
            // Interact with View programmatically
        }
        
        assertEquals("Expected Value", callbackValue)
    }
}
```

---

## 9. COMMON MISTAKES & SOLUTIONS

### Mistake 1: Setting state in factory
```kotlin
//  WRONG
AndroidView(
    factory = { context ->
        Spinner(context).apply {
            setSelection(selectedIndex)  // Only happens once!
        }
    }
)

//  RIGHT
AndroidView(
    factory = { context -> Spinner(context) },
    update = { spinner ->
        if (spinner.selectedItemPosition != selectedIndex) {
            spinner.setSelection(selectedIndex)
        }
    }
)
```

### Mistake 2: Not setting size
```kotlin
//  WRONG - View might not be visible
AndroidView(factory = { Spinner(it) })

//  RIGHT
AndroidView(
    factory = { Spinner(it) },
    modifier = Modifier.fillMaxWidth().height(50.dp)
)
```

### Mistake 3: Wrong ViewCompositionStrategy
```kotlin
//  WRONG for Fragment
binding.composeView.setViewCompositionStrategy(
    ViewCompositionStrategy.DisposeOnDetachedFromWindow
)

//  RIGHT for Fragment
binding.composeView.setViewCompositionStrategy(
    ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed
)
```

### Mistake 4: Listener doesn't have current state
```kotlin
//  WRONG - clickCount is captured at factory time
var clickCount by remember { mutableIntStateOf(0) }
AndroidView(
    factory = { Button(it).apply {
        setOnClickListener { println(clickCount) }  // Always 0!
    }}
)

//  RIGHT
var clickCount by remember { mutableIntStateOf(0) }
val currentCount by rememberUpdatedState(clickCount)
AndroidView(
    factory = { Button(it).apply {
        setOnClickListener { println(currentCount.value) }  // Always current
    }}
)
```

### Mistake 5: Not cleaning up resources
```kotlin
//  Resource leaks
AndroidView(
    factory = { context ->
        MyExpensiveView(context).apply {
            startListening()  // Never stops!
        }
    }
)

//  Proper cleanup
AndroidView(
    factory = { context ->
        MyExpensiveView(context).apply {
            startListening()
        }
    }
)
DisposableEffect(Unit) {
    onDispose {
        // Cleanup - though View instance might be inaccessible here
    }
}
```

---

## 10. ADVANCED TOPICS

### Q: How do I reuse Views in a Lazy list?

**A:** AndroidView supports view reuse:

```kotlin
@Composable
fun LazyListWithAndroidViews(items: List<Item>) {
    var viewHolder: MyCustomView? = null
    
    LazyColumn {
        items(items) { item ->
            AndroidView(
                factory = { context ->
                    if (viewHolder == null) {
                        viewHolder = MyCustomView(context)
                    }
                    viewHolder!!
                },
                update = { view ->
                    view.bind(item)  // Update view for new item
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(100.dp)
            )
        }
    }
}
```

### Q: How do I measure View size from Compose?

**A:** Use `onSizeChanged` modifier:

```kotlin
AndroidView(
    factory = { Spinner(it) },
    modifier = Modifier
        .fillMaxWidth()
        .onSizeChanged { size ->
            println("View size: ${size.width}x${size.height}")
        }
)
```

### Q: How do I theme AndroidView within Compose?

**A:** Pass theme context:

```kotlin
@Composable
fun ThemedAndroidView() {
    val context = LocalContext.current
    val themedContext = ContextThemeWrapper(context, R.style.AppTheme)
    
    AndroidView(
        factory = {
            Spinner(themedContext)  // Uses app theme
        }
    )
}
```

---

## Quick Decision Flow

```
Need to display something in Compose?
│
├─ Is it a traditional View (Spinner, RatingBar, etc.)?
│  ├─ No Compose equivalent AND no custom implementation?
│  │  └─ Use AndroidView(factory = { ... })
│  └─ Compose has equivalent (Button, Text, etc.)?
│     └─ Use Compose composable
│
└─ Need to add Compose to existing View-based UI?
   └─ Use ComposeView + setContent() + appropriate ViewCompositionStrategy
```

---