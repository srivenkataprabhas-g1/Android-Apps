# Room Database for Data Persistence: Comprehensive Study Guide

## Table of Contents
1. [Introduction](#introduction)
2. [Core Concepts & Definitions](#core-concepts--definitions)
3. [Room Architecture Components](#room-architecture-components)
4. [Setup & Configuration](#setup--configuration)
5. [Data Entities](#data-entities)
6. [Data Access Objects (DAOs)](#data-access-objects-daos)
7. [Database Class](#database-class)
8. [CRUD Operations](#crud-operations)
9. [Advanced Queries](#advanced-queries)
10. [Relationships](#relationships)
11. [Coroutines & Asynchronous Operations](#coroutines--asynchronous-operations)
12. [Database Migrations](#database-migrations)
13. [Best Practices & Architecture](#best-practices--architecture)
14. [Testing](#testing)
15. [Common FAQs](#common-faqs)

---

## Introduction

### What is Room?

**Room** is a **persistence library** that is part of **Android Jetpack**. It provides an abstraction layer over SQLite, allowing developers to easily create and use relational databases in Android applications without writing raw SQL queries.

### Why Use Room Instead of SQLite Directly?

| Aspect | SQLite | Room |
|--------|--------|------|
| **Compile-time verification** | No | Yes - queries verified at compile time |
| **Boilerplate code** | High | Low - convenient annotations |
| **Object mapping** | Manual | Automatic ORM (Object-Relational Mapping) |
| **Type safety** | Weak | Strong |
| **IDE support** | Limited | Full IntelliSense & autocomplete |
| **Migration support** | Manual, complex | Streamlined with automatic support |

### Key Benefits

- **Compile-time verification**: SQL queries are checked during compilation, catching errors before runtime
- **Convenience annotations**: `@Entity`, `@Dao`, `@Database` reduce repetitive code
- **Streamlined migrations**: Safe schema evolution with automatic and manual migration support
- **Reactive data binding**: Integrates seamlessly with Kotlin Flow, LiveData, and coroutines
- **Better performance**: Caches queries and provides optimized database access

---

## Core Concepts & Definitions

### Entity
- Represents a **table** in your database
- A Kotlin data class or Java class annotated with `@Entity`
- Each property represents a column in the table
- Must have a primary key

**Example:**
```kotlin
@Entity(tableName = "users")
data class User(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val name: String,
    val email: String
)
```

### Data Access Object (DAO)
- Interface or abstract class annotated with `@Dao`
- Contains methods to perform CRUD (Create, Read, Update, Delete) operations
- Room automatically generates implementations at compile time
- No direct SQL needed for basic operations (though you can write custom SQL with `@Query`)

**Example:**
```kotlin
@Dao
interface UserDao {
    @Insert
    suspend fun insertUser(user: User)
    
    @Query("SELECT * FROM users")
    fun getAllUsers(): Flow<List<User>>
    
    @Delete
    suspend fun deleteUser(user: User)
}
```

### Database
- Abstract class extending `RoomDatabase`
- Annotated with `@Database`, listing all entities and version
- Provides access point to the underlying SQLite database
- Must define abstract methods returning each DAO

**Example:**
```kotlin
@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
```

### Schema
- The **structure** of your database (tables, columns, constraints)
- Defined by your entity classes
- Changes require **migrations** when you update your app

---

## Room Architecture Components

### Component Hierarchy

```
┌─────────────────────────────────────┐
│         Your Application            │
│     (ViewModel, Repository, etc.)   │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│  Database Class (AppDatabase)       │
│  - Holds database instance          │
│  - Provides DAO access              │
└──────────────┬──────────────────────┘
               │
       ┌───────┴────────┐
       │                │
┌──────▼────────┐  ┌────▼──────────┐
│  DAO Methods  │  │  DAO Methods  │
│  (UserDao)    │  │  (OrderDao)   │
└──────┬────────┘  └────┬──────────┘
       │                │
┌──────▼────────┐  ┌────▼──────────┐
│ Entities      │  │ Entities      │
│ (User table)  │  │ (Order table) │
└───────────────┘  └───────────────┘
       │                │
└──────┬────────┬───────┘
       │        │
    ┌──▼────────▼──┐
    │  SQLite DB   │
    └──────────────┘
```

---

## Setup & Configuration

### Step 1: Add Dependencies

In your `build.gradle` (Module: app):

```gradle
dependencies {
    // Room dependencies
    def room_version = "2.8.4"
    
    implementation "androidx.room:room-runtime:$room_version"
    
    // KSP (Kotlin Symbol Processing) for annotation processing
    ksp "androidx.room:room-compiler:$room_version"
    
    // Optional: Kotlin Extensions and Coroutines support
    implementation "androidx.room:room-ktx:$room_version"
    
    // Optional: For testing
    testImplementation "androidx.room:room-testing:$room_version"
}
```

### Step 2: Add KSP Plugin

In `build.gradle` (Module: app), add KSP plugin:

```gradle
plugins {
    id 'kotlin-kapt'  // or 'com.google.devtools.ksp' for KSP
    // ... other plugins
}
```

### Step 3: Minimum Android Version

Room requires **Android API 16+** (Android 4.1 and above).

---

## Data Entities

### Defining Entities

An entity is a **Kotlin data class** or Java class representing a table. Each property becomes a column.

```kotlin
@Entity(tableName = "users")
data class User(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    
    @ColumnInfo(name = "user_name")
    val name: String,
    
    @ColumnInfo(name = "user_email")
    val email: String,
    
    val age: Int? = null,  // Nullable
    
    val isActive: Boolean = true
)
```

### Key Annotations

| Annotation | Purpose | Example |
|-----------|---------|---------|
| `@Entity` | Marks class as database table | `@Entity(tableName = "users")` |
| `@PrimaryKey` | Defines primary key | `@PrimaryKey(autoGenerate = true)` |
| `@ColumnInfo` | Customizes column name | `@ColumnInfo(name = "user_email")` |
| `@Ignore` | Excludes field from database | `@Ignore val tempField: String` |
| `@Embedded` | Flattens nested objects | `@Embedded val address: Address` |
| `@Relation` | Defines relationships | See Relationships section |

### Primary Keys

Every entity **must** have exactly one primary key:

```kotlin
// Auto-incrementing primary key
@PrimaryKey(autoGenerate = true)
val id: Int = 0

// Composite primary key (multiple columns)
@Entity(primaryKeys = ["userId", "orderId"])
data class UserOrder(
    val userId: Int,
    val orderId: Int,
    val quantity: Int
)

// Custom primary key
@PrimaryKey
val email: String  // Email is unique identifier
```

### Column Constraints

```kotlin
@Entity(
    tableName = "users",
    indices = [
        Index(value = ["email"], unique = true),  // Unique constraint
        Index(value = ["firstName", "lastName"])  // Composite index
    ]
)
data class User(
    @PrimaryKey val id: Int,
    val firstName: String,
    val lastName: String,
    val email: String
)
```

### Embedded Objects

Flatten nested objects into a single table:

```kotlin
data class Address(
    val street: String,
    val city: String,
    val zipCode: String
)

@Entity
data class User(
    @PrimaryKey val id: Int,
    val name: String,
    @Embedded val address: Address  // Flattened into user table
)

// Generated table columns: id, name, street, city, zipCode
```

---

## Data Access Objects (DAOs)

### DAO Overview

DAOs are the **primary access point** for your database. Room generates implementations automatically at compile time.

```kotlin
@Dao
interface UserDao {
    // Insert, Update, Delete, Query methods
}
```

### Insert Operations

#### Simple Insert

```kotlin
@Dao
interface UserDao {
    @Insert
    suspend fun insertUser(user: User)
    
    @Insert
    suspend fun insertUsers(users: List<User>)
    
    @Insert
    suspend fun insertMultiple(user1: User, user2: User)
}
```

#### Insert with Conflict Strategy

When inserting a record with an existing primary key:

```kotlin
@Dao
interface UserDao {
    // Replace existing record
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrReplace(user: User)
    
    // Ignore if exists
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insertIfNew(user: User)
    
    // Abort transaction if conflict
    @Insert(onConflict = OnConflictStrategy.ABORT)
    suspend fun insertStrict(user: User)
}
```

#### Return Insert ID

```kotlin
@Dao
interface UserDao {
    @Insert
    suspend fun insertUser(user: User): Long  // Returns rowId
    
    @Insert
    suspend fun insertUsers(users: List<User>): List<Long>
}
```

### Update Operations

```kotlin
@Dao
interface UserDao {
    @Update
    suspend fun updateUser(user: User)
    
    @Update
    suspend fun updateUsers(users: List<User>)
    
    // Returns number of rows updated
    @Update
    suspend fun updateUserCount(user: User): Int
}
```

**How it works:** Room uses the primary key to find the matching record and updates all columns.

### Delete Operations

```kotlin
@Dao
interface UserDao {
    @Delete
    suspend fun deleteUser(user: User)
    
    @Delete
    suspend fun deleteUsers(users: List<User>)
    
    // Returns number of rows deleted
    @Delete
    suspend fun deleteUserCount(user: User): Int
}
```

### Query Operations

#### Simple SELECT Query

```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAllUsers(): List<User>
    
    // With suspend for coroutines
    @Query("SELECT * FROM users")
    suspend fun getAllUsersSuspend(): List<User>
    
    // With Flow for reactive updates
    @Query("SELECT * FROM users")
    fun getAllUsersFlow(): Flow<List<User>>
}
```

#### WHERE Clause with Parameters

```kotlin
@Dao
interface UserDao {
    // Single parameter
    @Query("SELECT * FROM users WHERE age > :minAge")
    fun getUsersOlderThan(minAge: Int): List<User>
    
    // Multiple parameters
    @Query("SELECT * FROM users WHERE age BETWEEN :minAge AND :maxAge")
    fun getUsersByAgeRange(minAge: Int, maxAge: Int): List<User>
    
    // LIKE operator for text search
    @Query("SELECT * FROM users WHERE name LIKE :searchQuery")
    fun searchUsers(searchQuery: String): List<User>
    
    // Using it: dao.searchUsers("%John%")
}
```

#### Return Subset of Columns

```kotlin
data class UserPreview(
    @ColumnInfo(name = "id") val userId: Int,
    @ColumnInfo(name = "user_name") val userName: String
)

@Dao
interface UserDao {
    @Query("SELECT id, user_name FROM users")
    fun getUserPreviews(): List<UserPreview>
}
```

#### Collection Parameters

```kotlin
@Dao
interface UserDao {
    // Query multiple users by IDs
    @Query("SELECT * FROM users WHERE id IN (:userIds)")
    fun getUsersByIds(userIds: List<Int>): List<User>
    
    // Usage: dao.getUsersByIds(listOf(1, 2, 3))
}
```

#### Aggregation Functions

```kotlin
@Dao
interface UserDao {
    @Query("SELECT COUNT(*) FROM users")
    fun getUserCount(): Int
    
    @Query("SELECT AVG(age) FROM users")
    fun getAverageAge(): Double
    
    @Query("SELECT MAX(age) FROM users")
    fun getOldestAge(): Int
}
```

#### GROUP BY and ORDER BY

```kotlin
data class AgeCount(
    val age: Int,
    @ColumnInfo(name = "user_count")
    val count: Int
)

@Dao
interface UserDao {
    @Query("SELECT age, COUNT(*) as user_count FROM users GROUP BY age")
    fun getUsersByAge(): List<AgeCount>
    
    @Query("SELECT * FROM users ORDER BY name ASC")
    fun getUsersSortedByName(): List<User>
}
```

---

## Database Class

### Creating the Database

```kotlin
@Database(
    entities = [User::class, Order::class],  // All entities
    version = 1,                              // Schema version
    exportSchema = false                      // For debugging
)
abstract class AppDatabase : RoomDatabase() {
    // Abstract methods for each DAO
    abstract fun userDao(): UserDao
    abstract fun orderDao(): OrderDao
}
```

### Singleton Pattern (Recommended)

Always use a **singleton** to avoid multiple database instances:

```kotlin
@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
    
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null
        
        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "app_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}
```

### Creating Database Instance

```kotlin
// Basic
val db = Room.databaseBuilder(
    context,
    AppDatabase::class.java,
    "my_database"
).build()

// With migrations
val db = Room.databaseBuilder(
    context,
    AppDatabase::class.java,
    "my_database"
)
    .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
    .build()

// Fallback to destructive migration (loses data!)
val db = Room.databaseBuilder(
    context,
    AppDatabase::class.java,
    "my_database"
)
    .fallbackToDestructiveMigration()
    .build()
```

### Accessing DAOs

```kotlin
val userDao = db.userDao()
val users = userDao.getAllUsers()
```

---

## CRUD Operations

### C - CREATE (Insert)

```kotlin
// Single insert
val newUser = User(
    id = 0,  // autoGenerate will handle this
    name = "John Doe",
    email = "john@example.com"
)
userDao.insertUser(newUser)

// Multiple inserts
val users = listOf(
    User(0, "Alice", "alice@example.com"),
    User(0, "Bob", "bob@example.com")
)
userDao.insertUsers(users)
```

### R - READ (Query)

```kotlin
// Get all users
val allUsers = userDao.getAllUsers()

// Get specific user
val user = userDao.getUserById(1)

// Get with filter
val adults = userDao.getUsersOlderThan(18)

// Reactive (observe changes)
userDao.getAllUsersFlow().collect { users ->
    updateUI(users)
}
```

### U - UPDATE

```kotlin
val updatedUser = user.copy(name = "Jane Doe")
userDao.updateUser(updatedUser)
```

### D - DELETE

```kotlin
// Delete single user
userDao.deleteUser(user)

// Delete all
userDao.deleteAllUsers()

// Delete by condition (custom query)
userDao.deleteUsersByAge(minAge = 100)
```

---

## Advanced Queries

### JOIN Queries

```kotlin
@Entity
data class Order(
    @PrimaryKey val orderId: Int,
    val userId: Int,  // Foreign key
    val amount: Double
)

data class UserWithOrders(
    @Embedded val user: User,
    @Relation(
        parentColumn = "id",
        entityColumn = "userId"
    )
    val orders: List<Order>
)

@Dao
interface UserDao {
    @Transaction
    @Query("SELECT * FROM users")
    fun getUsersWithOrders(): List<UserWithOrders>
}
```

### Raw SQL Queries

For complex queries, use raw SQL:

```kotlin
@Dao
interface CustomDao {
    @Query("""
        SELECT u.id, u.user_name, COUNT(o.orderId) as orderCount
        FROM users u
        LEFT JOIN orders o ON u.id = o.userId
        GROUP BY u.id
        HAVING orderCount > :minOrders
    """)
    fun getUsersWithOrderCount(minOrders: Int): List<UserOrderSummary>
}
```

### Cursor Queries (Direct Row Access)

```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users WHERE age > :minAge LIMIT 5")
    fun loadRawUsersOlderThan(minAge: Int): Cursor
}

// Usage
val cursor = userDao.loadRawUsersOlderThan(30)
while (cursor.moveToNext()) {
    val userId = cursor.getInt(cursor.getColumnIndex("id"))
    val userName = cursor.getString(cursor.getColumnIndex("user_name"))
}
cursor.close()
```

---

## Relationships

### One-to-One Relationship

**Example:** One user has one profile

```kotlin
@Entity
data class UserEntity(
    @PrimaryKey val id: Int,
    val name: String
)

@Entity
data class ProfileEntity(
    @PrimaryKey val profileId: Int,
    val userId: Int,  // Foreign key
    val bio: String
)

// Query together
data class UserWithProfile(
    @Embedded val user: UserEntity,
    @Relation(
        parentColumn = "id",
        entityColumn = "userId"
    )
    val profile: ProfileEntity
)

@Dao
interface UserDao {
    @Transaction
    @Query("SELECT * FROM UserEntity")
    fun getUsersWithProfiles(): List<UserWithProfile>
}
```

### One-to-Many Relationship

**Example:** One user has many orders

```kotlin
@Entity
data class UserEntity(
    @PrimaryKey val id: Int,
    val name: String
)

@Entity
data class OrderEntity(
    @PrimaryKey val orderId: Int,
    val userId: Int,
    val amount: Double
)

data class UserWithOrders(
    @Embedded val user: UserEntity,
    @Relation(
        parentColumn = "id",
        entityColumn = "userId"
    )
    val orders: List<OrderEntity>
)

@Dao
interface UserDao {
    @Transaction
    @Query("SELECT * FROM UserEntity")
    fun getUsersWithOrders(): List<UserWithOrders>
}
```

### Many-to-Many Relationship

**Example:** Students and Courses (many students → many courses)

```kotlin
@Entity
data class StudentEntity(
    @PrimaryKey val studentId: Int,
    val name: String
)

@Entity
data class CourseEntity(
    @PrimaryKey val courseId: Int,
    val title: String
)

// Junction table
@Entity(
    primaryKeys = ["studentId", "courseId"],
    foreignKeys = [
        ForeignKey(StudentEntity::class, ["studentId"], ["studentId"]),
        ForeignKey(CourseEntity::class, ["courseId"], ["courseId"])
    ]
)
data class StudentCourseCrossRef(
    val studentId: Int,
    val courseId: Int
)

// Query class
data class StudentWithCourses(
    @Embedded val student: StudentEntity,
    @Relation(
        parentColumn = "studentId",
        entityColumn = "courseId",
        associateBy = Junction(StudentCourseCrossRef::class)
    )
    val courses: List<CourseEntity>
)

@Dao
interface StudentDao {
    @Transaction
    @Query("SELECT * FROM StudentEntity")
    fun getStudentsWithCourses(): List<StudentWithCourses>
}
```

### Important: @Transaction Annotation

When querying relationships, **always use `@Transaction`**:

```kotlin
@Dao
interface UserDao {
    @Transaction  // ⭐ Ensures consistency
    @Query("SELECT * FROM users")
    fun getUsersWithOrders(): List<UserWithOrders>
}
```

---

## Coroutines & Asynchronous Operations

### Why Async?

Room **blocks the main thread** if you call database queries on the UI thread. You **must** use:
- **`suspend` functions** for one-shot operations
- **`Flow`** for observing changes
- **`LiveData`** for lifecycle-aware observation

### Suspend Functions

Mark DAO methods as `suspend` for use with coroutines:

```kotlin
@Dao
interface UserDao {
    // One-shot operations
    @Insert
    suspend fun insertUser(user: User)
    
    @Delete
    suspend fun deleteUser(user: User)
    
    @Query("SELECT * FROM users WHERE id = :userId")
    suspend fun getUserById(userId: Int): User
}
```

**Usage in ViewModel:**

```kotlin
class UserViewModel(private val userDao: UserDao) : ViewModel() {
    fun addUser(user: User) {
        viewModelScope.launch {
            userDao.insertUser(user)  // Safe to call from coroutine
        }
    }
}
```

### Flow for Reactive Queries

For observing continuous changes, use `Flow`:

```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAllUsers(): Flow<List<User>>
    
    @Query("SELECT * FROM users WHERE age > :minAge")
    fun getUsersOlderThan(minAge: Int): Flow<List<User>>
}
```

**Usage in ViewModel:**

```kotlin
class UserViewModel(private val userDao: UserDao) : ViewModel() {
    val allUsers: StateFlow<List<User>> = userDao.getAllUsers()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
}
```

### LiveData Integration

Convert Flow to LiveData:

```kotlin
class UserViewModel(private val userDao: UserDao) : ViewModel() {
    val allUsers: LiveData<List<User>> = userDao.getAllUsers()
        .asLiveData()
}
```

### Coroutine Dispatchers

Room **automatically handles thread dispatch** for:
- `suspend` functions → Background thread
- `Flow` functions → Background thread
- `LiveData` functions → Background thread

**You don't need** to wrap with `withContext(Dispatchers.IO)` when using suspend/Flow!

---

## Database Migrations

### What are Migrations?

When you change your database schema (add/remove columns, tables, etc.), you need to migrate existing data safely.

### Version Management

Increment the database version whenever you change the schema:

```kotlin
// Version 1
@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase()

// After schema change
@Database(entities = [User::class], version = 2)
abstract class AppDatabase : RoomDatabase()
```

### Automatic Migrations

Room can automatically handle simple schema changes (v2.3+):

```kotlin
@Database(entities = [User::class], version = 2)
abstract class AppDatabase : RoomDatabase()

// Room handles: adding columns, renaming columns
// (Database builder doesn't need addMigrations() for simple cases)
```

### Manual Migrations

For complex changes, define migration paths:

```kotlin
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Add new column to users table
        database.execSQL(
            "ALTER TABLE users ADD COLUMN email TEXT DEFAULT 'unknown@example.com'"
        )
    }
}

val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Create new table
        database.execSQL("""
            CREATE TABLE user_profiles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                bio TEXT
            )
        """)
    }
}

// Register migrations
val db = Room.databaseBuilder(context, AppDatabase::class.java, "db")
    .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
    .build()
```

### Migration Testing

```kotlin
@RunWith(AndroidJUnit4::class)
class MigrationTest {
    private val testDb = MigrationTestHelper(
        ApplicationProvider.getApplicationContext(),
        AppDatabase::class.java,
        listOf(),
        FrameworkSQLiteOpenHelperFactory()
    )
    
    @Test
    fun migrate1To2() {
        // Create version 1 database
        var db = testDb.createDatabase(TEST_DB, 1)
        db.execSQL("INSERT INTO users VALUES (1, 'John', 'john@example.com')")
        db.close()
        
        // Run migration
        testDb.runMigrationsAndValidate(TEST_DB, 2, true, MIGRATION_1_2)
    }
}
```

### Fallback Strategy (Data Loss!)

If you can't migrate safely, Room can destroy and recreate:

```kotlin
val db = Room.databaseBuilder(context, AppDatabase::class.java, "db")
    .fallbackToDestructiveMigration()  // ⚠️ Deletes all data!
    .build()

// More selective:
.fallbackToDestructiveMigrationFrom(1)  // Only if upgrading from version 1
.fallbackToDestructiveMigrationOnDowngrade()  // Only on downgrade
```

---

## Best Practices & Architecture

### Repository Pattern

**Goal:** Abstract data source (DB, API) from UI logic

```kotlin
// Data layer
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAllUsers(): Flow<List<User>>
    
    @Insert
    suspend fun insertUser(user: User)
}

// Repository (bridge between DAO and UI)
class UserRepository(private val userDao: UserDao) {
    val allUsers: Flow<List<User>> = userDao.getAllUsers()
    
    suspend fun addUser(user: User) {
        userDao.insertUser(user)
    }
}

// UI layer
class UserViewModel(private val repository: UserRepository) : ViewModel() {
    val users: StateFlow<List<User>> = repository.allUsers
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(),
            initialValue = emptyList()
        )
    
    fun addUser(name: String, email: String) {
        viewModelScope.launch {
            repository.addUser(User(0, name, email))
        }
    }
}
```

### Clean Architecture Layers

```
┌─────────────────────────────┐
│   Presentation Layer        │
│   (UI, ViewModel)           │
└──────────────┬──────────────┘
               │ uses
┌──────────────▼──────────────┐
│   Domain Layer              │
│   (Use Cases, Repositories) │
└──────────────┬──────────────┘
               │ uses
┌──────────────▼──────────────┐
│   Data Layer                │
│   (DAO, Database, Entities) │
└─────────────────────────────┘
```

### Dependency Injection (Hilt)

```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repository: UserRepository
) : ViewModel() {
    // ...
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    @Singleton
    @Provides
    fun provideDatabase(context: Context): AppDatabase =
        Room.databaseBuilder(context, AppDatabase::class.java, "db").build()
    
    @Singleton
    @Provides
    fun provideUserDao(db: AppDatabase): UserDao = db.userDao()
    
    @Singleton
    @Provides
    fun provideUserRepository(dao: UserDao): UserRepository =
        UserRepository(dao)
}
```

### Type Converters (For Complex Types)

Store custom types in the database:

```kotlin
class DateConverter {
    @TypeConverter
    fun fromTimestamp(value: Long?): Date? =
        value?.let { Date(it) }
    
    @TypeConverter
    fun dateToTimestamp(date: Date?): Long? =
        date?.time
}

@Database(entities = [User::class], version = 1)
@TypeConverters(DateConverter::class)
abstract class AppDatabase : RoomDatabase() {
    // ...
}

// Now use Date in entities
@Entity
data class User(
    @PrimaryKey val id: Int,
    val name: String,
    val createdAt: Date  // Stored as LONG
)
```

---

## Testing

### Unit Testing DAOs

```kotlin
@RunWith(AndroidJUnit4::class)
class UserDaoTest {
    private lateinit var db: AppDatabase
    private lateinit var userDao: UserDao
    
    @Before
    fun setup() {
        // Use in-memory database for testing
        db = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            AppDatabase::class.java
        ).build()
        userDao = db.userDao()
    }
    
    @After
    fun tearDown() {
        db.close()
    }
    
    @Test
    fun insertAndRetrieveUser() = runBlocking {
        // Arrange
        val user = User(0, "John", "john@example.com")
        
        // Act
        userDao.insertUser(user)
        val retrieved = userDao.getUserById(1)
        
        // Assert
        assertEquals(retrieved.name, "John")
    }
    
    @Test
    fun getAllUsersReturnsInsertedUsers() = runBlocking {
        // Arrange
        val users = listOf(
            User(0, "Alice", "alice@example.com"),
            User(0, "Bob", "bob@example.com")
        )
        
        // Act
        userDao.insertUsers(users)
        val retrieved = userDao.getAllUsers()
        
        // Assert
        assertEquals(retrieved.size, 2)
    }
}
```

### Testing with Flow

```kotlin
@Test
fun getAllUsersReturnsFlowOfUsers() = runBlocking {
    val user = User(0, "John", "john@example.com")
    userDao.insertUser(user)
    
    userDao.getAllUsers().test {
        val users = awaitItem()
        assertEquals(users.size, 1)
        assertEquals(users[0].name, "John")
        awaitComplete()
    }
}
```

---

## Common FAQs

### Q1: Do I need to mark DAO methods as `suspend`?

**A:** No, but you should:
- `suspend` is **not mandatory** - Room automatically handles threading
- **Why use it?** Makes code cleaner and type-safe with coroutines
- Without `suspend`, you must manually wrap with `withContext(Dispatchers.IO)`

```kotlin
// With suspend (recommended)
@Query("SELECT * FROM users")
suspend fun getUsers(): List<User>

// Without suspend (less ideal)
@Query("SELECT * FROM users")
fun getUsers(): List<User>

// Usage difference:
// With suspend:
val users = userDao.getUsers()  // Can call from any coroutine context

// Without suspend:
val users = withContext(Dispatchers.IO) { userDao.getUsers() }  // Must wrap
```

### Q2: Can I use Room without coroutines?

**A:** Yes, but not recommended:
- Use `LiveData` for automatic UI updates
- Synchronous functions **block** the main thread
- Best practice: Always use async (suspend/Flow/LiveData)

```kotlin
// Not recommended (blocks UI thread)
@Query("SELECT * FROM users")
fun getUsers(): List<User>

// Better
@Query("SELECT * FROM users")
fun getUsersLiveData(): LiveData<List<User>>

// Best
@Query("SELECT * FROM users")
fun getUsersFlow(): Flow<List<User>>
```

### Q3: What's the difference between Flow and LiveData?

| Feature | Flow | LiveData |
|---------|------|----------|
| **Lifecycle-aware** | No | Yes |
| **Thread safe** | Yes | Yes |
| **Cancellable** | Yes | No |
| **Backpressure** | Yes | No |
| **Cold stream** | Yes (restarts on collect) | Hot stream |
| **Use case** | General reactive programming | UI observation |

```kotlin
// Flow - good for repos
fun getAllUsers(): Flow<List<User>>

// LiveData - good for UI (lifecycle-aware)
val users: LiveData<List<User>> = repository.getAllUsers().asLiveData()
```

### Q4: How do I handle large datasets (pagination)?

**A:** Use Paging library:

```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users ORDER BY id ASC")
    fun getUsersPaged(): PagingSource<Int, User>
}

// In repository/ViewModel
val flow = Paging3.from(userDao.getUsersPaged())
```

### Q5: Can I have multiple databases in one app?

**A:** Yes, but unusual. Create separate database classes:

```kotlin
@Database(entities = [User::class], version = 1)
class AppDatabase : RoomDatabase() { }

@Database(entities = [Product::class], version = 1)
class ProductDatabase : RoomDatabase() { }
```

### Q6: How do I clear all data?

**A:** Options:
```kotlin
// Delete all from a table
@Query("DELETE FROM users")
suspend fun deleteAllUsers()

// Or
userDao.deleteAllUsers()

// Clear entire database
db.clearAllTables()
```

### Q7: What's the best way to structure my files?

**A:** By layer (Clean Architecture):

```
src/
  main/
    java/
      data/
        entity/
          User.kt
          Order.kt
        dao/
          UserDao.kt
          OrderDao.kt
        database/
          AppDatabase.kt
        repository/
          UserRepository.kt
      domain/
        usecase/
          GetUsersUseCase.kt
      ui/
        viewmodel/
          UserViewModel.kt
        fragment/
          UserFragment.kt
```

### Q8: How do I log Room queries?

**A:** Use QueryCallback (Room 2.3.0+):

```kotlin
if (BuildConfig.DEBUG) {
    dbBuilder.setQueryCallback(
        { sqlQuery, bindArgs ->
            Log.d("Room", "Query: $sqlQuery")
            Log.d("Room", "Args: $bindArgs")
        },
        Executors.newSingleThreadExecutor()
    )
}
```

### Q9: Can I use foreign keys?

**A:** Yes (though Room doesn't enforce them by default):

```kotlin
@Entity(
    foreignKeys = [
        ForeignKey(
            entity = User::class,
            parentColumns = ["id"],
            childColumns = ["userId"],
            onDelete = ForeignKey.CASCADE  // Delete orders when user deleted
        )
    ]
)
data class Order(
    @PrimaryKey val orderId: Int,
    val userId: Int
)
```

### Q10: How do I export schema for version control?

**A:** Enable in database class:

```kotlin
@Database(entities = [User::class], version = 1, exportSchema = true)
abstract class AppDatabase : RoomDatabase() { }
```

Schemas are saved to `build/schemas/`.

---

## Summary Checklist

### Before Starting
- [ ] Add Room dependencies to `build.gradle`
- [ ] Add KSP plugin
- [ ] Set min API level to 16+

### Creating Database
- [ ] Define entities with `@Entity` and `@PrimaryKey`
- [ ] Create DAOs with CRUD methods
- [ ] Create database class extending `RoomDatabase`
- [ ] Implement singleton pattern

### Using the Database
- [ ] Use repository pattern for data access
- [ ] Use suspend functions for one-shot queries
- [ ] Use Flow for observing data
- [ ] Use LiveData for UI lifecycle-awareness
- [ ] Test with in-memory database

### Maintenance
- [ ] Increment version on schema changes
- [ ] Create migrations for data safety
- [ ] Test migrations thoroughly
- [ ] Keep entity classes clean
- [ ] Follow Clean Architecture principles

---

## References & Further Learning

- [Android Developers: Room Persistence Library](https://developer.android.com/training/data-storage/room)
- [Room on Android Jetpack](https://developer.android.com/jetpack/androidx/releases/room)
- [Kotlin Coroutines Guide](https://kotlinlang.org/docs/coroutines-overview.html)
- [Android Architecture Components](https://developer.android.com/topic/architecture)
- [Flow Documentation](https://developer.android.com/kotlin/flow)

---

**Last Updated:** January 2026
**Android Room Version:** 2.8.4+

