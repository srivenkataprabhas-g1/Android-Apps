
Adaptive Layouts in Android (Jetpack Compose)
Build an Adaptive App with Dynamic Navigation
1. What Is an Adaptive App?
Definition

An adaptive app is an application that changes its layout, navigation, and content organization based on:

Screen size

Orientation

	Device posture (foldables)

Platform (phones, tablets, ChromeOS, desktop)

Instead of scaling or stretching UI elements, adaptive apps rearrange content to make better use of available space.

Devices to Support

Phones (small screens)

Tablets (large screens)

Foldables (changing posture)

ChromeOS / Desktop

Why Adaptive Layouts Matter

Users expect the same app to work well on all devices

Large screens improve productivity only if UI is optimized

Poor large-screen design leads to:

Wasted space

Hard-to-reach touch targets

Repetitive navigation

2. Reply App Overview (Reference App)
App Type

Email-style app

Similar to Gmail

Used as a learning reference for adaptive layouts

Mailbox Categories

Inbox

Sent

Drafts

Spam

3. Project Structure (Important for Exams)
Data Layer
data/
 ├─ Email.kt
 ├─ MailboxType.kt
 ├─ LocalEmailsDataProvider.kt


Purpose

Defines email model

Provides fake/local data

Groups emails by mailbox

UI Layer
ui/
 ├─ ReplyViewModel.kt
 ├─ ReplyUiState.kt
 ├─ ReplyApp.kt
 ├─ ReplyHomeScreen.kt
 ├─ ReplyHomeContent.kt
 ├─ ReplyDetailsScreen.kt


Purpose

Holds UI logic

Manages state

Displays screens based on state

4. Architecture & State Management
Core Architecture Pattern

MVVM (Model–View–ViewModel)

Single source of truth

State-driven UI

ViewModel Initialization
init {
    initializeUIState()
}


The UI state is initialized once when the ViewModel is created.

UI State Creation Logic
private fun initializeUIState() {
    val mailboxes = LocalEmailsDataProvider.allEmails
        .groupBy { it.mailbox }

    _uiState.value = ReplyUiState(
        mailboxes = mailboxes,
        currentSelectedEmail =
            mailboxes[MailboxType.Inbox]?.get()
                ?: LocalEmailsDataProvider.defaultEmail
    )
}

Key Points

Emails are grouped by mailbox

Default email is selected

UI state is immutable

UI reacts automatically to state changes

Key Takeaway

UI does not control logic

ViewModel controls everything

State change triggers recomposition

5. ReplyApp – Screen-Level Composable
Role of ReplyApp

Entry point of the UI

Connects ViewModel with UI

Passes state and event callbacks

Example
@Composable
fun ReplyApp() {
    val viewModel: ReplyViewModel = viewModel()
    val replyUiState = viewModel.uiState.collectAsState().value

    ReplyHomeScreen(
        replyUiState = replyUiState,
        onTabPressed = { mailbox ->
            viewModel.updateCurrentMailbox(mailbox)
            viewModel.resetHomeScreenStates()
        },
        onEmailCardPressed = { email ->
            viewModel.updateDetailsScreenStates(email)
        },
        onDetailScreenBackPressed = {
            viewModel.resetHomeScreenStates()
        }
    )
}

Important Concept

UI does not perform navigation

UI only emits events

ViewModel updates state

State controls which screen is shown

6. Navigation Without NavHost (Core Concept)
Why Navigation Component Is Not Used

Only two screens

No complex back stack

State-based navigation is simpler

Screens

Home screen (email list)

Details screen (email content)

Key Insight

Jetpack Compose allows navigation purely through state, without NavController or NavHost.

7. Conditional Navigation Using State
Key State Variable
replyUiState.isShowingHomepage

Navigation Logic
if (replyUiState.isShowingHomepage) {
    // Show Home Screen
} else {
    // Show Details Screen
}

Implementation
@Composable
fun ReplyHomeScreen(
    replyUiState: ReplyUiState,
    onTabPressed: (MailboxType) -> Unit,
    onEmailCardPressed: (Int) -> Unit,
    onDetailScreenBackPressed: () -> Unit
) {
    if (replyUiState.isShowingHomepage) {
        ReplyAppContent(
            replyUiState = replyUiState,
            onTabPressed = onTabPressed,
            onEmailCardPressed = onEmailCardPressed
        )
    } else {
        ReplyDetailsScreen(
            replyUiState = replyUiState,
            onBackPressed = onDetailScreenBackPressed
        )
    }
}

Exam Insight

Navigation is a result of state

No NavController needed

Compose recomposes UI automatically

8. Handling Back Button Without NavHost
Problem

No back stack

System back button does nothing by default

Solution: BackHandler
import androidx.activity.compose.BackHandler

@Composable
fun ReplyDetailsScreen(
    replyUiState: ReplyUiState,
    onBackPressed: () -> Unit
) {
    BackHandler {
        onBackPressed()
    }

    // Details UI
}

Key Takeaways

Back navigation must be handled manually

Required when not using Navigation Component

BackHandler intercepts system back press

9. Testing on Large Screens
Why Testing Is Critical

UI may stretch incorrectly

Touch targets may become unreachable

Content may be centered poorly

Navigation may feel inefficient

10. Resizable Emulator (Very Important)
What It Is

A single emulator that can simulate:

Phones

Tablets

Foldables

Different orientations

Window resizing

Benefits

No need for multiple emulators

Real-time layout testing

Faster iteration

How to Create

Android Studio → Tools → Device Manager

Create Virtual Device

Select Resizable (Experimental)

API level 34 or higher

Finish setup

11. Tablet Mode Observations (Reply App)
Problems Observed

UI stretched horizontally

Content centered

Navigation far from fingers

Wasted screen space

Lesson

Scaling UI is not adaptive design

Layout must be rearranged

12. Designing for Large Screens
Core Design Principles

Avoid center-only content

Minimize navigation steps

Use available width

Recommended Patterns

Side navigation rail

Two-pane layouts

Persistent detail views

Example Improvement

Left pane: Email list

Right pane: Email details

No back navigation needed

13. Orientation & Window Size
Important Notes

Phones: Portrait is primary

Tablets: Landscape is primary

Adaptive Design Depends On

Window size class

Orientation

Device posture (folded/unfolded)

14. When to Use State-Based Navigation
Scenario	Recommendation
Small app (2 screens)	Use state-based navigation
Complex flows	Use NavHost
Large screens	Use adaptive layouts
Multiple form factors	Use resizable emulator
15. Core Concepts Summary (Revision Sheet)
Key Learnings

State drives UI

Compose navigation can be state-based

No NavHost required for simple apps

BackHandler is required without NavController

Adaptive layouts are essential for large screens

Testing on resizable emulator is mandatory

One-Line Memory Trick

State changes → UI recomposes → screen changes

16. Frequently Asked Questions (FAQs)
Q1. Why not always use NavHost?

For small apps with few screens, NavHost adds unnecessary complexity. State-based navigation is simpler and clearer.

Q2. Is state-based navigation scalable?

No. For complex flows, deep links, or multiple back stacks, use the Navigation Component.

Q3. Does adaptive layout mean different apps?

No. Same app, different layout strategies.

Q4. What is the biggest mistake in large-screen design?

Stretching phone UI instead of reorganizing content.

Q5. Why is ViewModel important here?

It centralizes navigation and UI state, making the app predictable and testable.

17. Final Takeaway

Adaptive layouts are not optional in modern Android development.
Jetpack Compose makes adaptivity powerful by letting state control UI and navigation, enabling clean, scalable, and device-aware applications.